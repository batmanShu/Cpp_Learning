# 目录
<!-- GFM-TOC -->
- [目录](#目录)
- [多态](#多态)
  - [静态多态](#静态多态)
    - [函数重载](#函数重载)
      - [为什么C语言不能实现函数重载](#为什么c语言不能实现函数重载)
    - [模板](#模板)
    - [宏定义](#宏定义)
  - [动态多态](#动态多态)
    - [<span id="jump">虚函数</span>](#虚函数)
- [关键字](#关键字)
  - [static](#static)
  - [const](#const)
  - [virtual](#virtual)
  - [extern](#extern)
  - [inline](#inline)
  - [volatile](#volatile)
  - [friend](#friend)
  - [mutable](#mutable)
  - [constexpr](#constexpr)
- [四种转换类型](#四种转换类型)
  - [static_cast](#static_cast)
  - [dynamic_cast](#dynamic_cast)
  - [const_cast](#const_cast)
  - [reinterpret_cast](#reinterpret_cast)
- [c++11](#c11)
  - [智能指针](#智能指针)
  - [右值](#右值)
    - [右值引用](#右值引用)
    - [std::move](#stdmove)
    - [std::forward](#stdforward)
    - [lambda表达式](#lambda表达式)
- [STL](#stl)
  - [vector扩容原理](#vector扩容原理)
  - [什么时候迭代器会失效](#什么时候迭代器会失效)
- [类](#类)
  - [sizeof(类)](#sizeof类)
  - [类和结构体的区别](#类和结构体的区别)
  - [类模板和模板类](#类模板和模板类)
  - [类中数据成员的初始化](#类中数据成员的初始化)
  - [基类与派生类之间同名函数重载问题](#基类与派生类之间同名函数重载问题)
- [其他(未归类)](#其他未归类)
  - [动态链接 静态链接](#动态链接-静态链接)
  - [数组指针和指针数组的区别](#数组指针和指针数组的区别)
  - [深拷贝和浅拷贝的区别](#深拷贝和浅拷贝的区别)
  - [关于指针和引用的一些思考](#关于指针和引用的一些思考)
<!-- GFM-TOC -->

# 多态

## 静态多态
编译时的多态

### 函数重载

基于不同的参数列表，同一个函数名字可以指向不同的函数定义，实现原理在于编译器根据不同的参数列表对同名函数进行名字重整，而后这些同名函数就变成了彼此不同的函数

#### 为什么C语言不能实现函数重载
编译器在编译.c文件时，只会给函数进行简单的重命名；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错

### 模板

### 宏定义

## 动态多态
运行时的多态

### <span id="jump">虚函数</span>


# 关键字
static
---
+ 静态局部变量
+ 静态全局变量 只在本文件可见
+ 静态函数 不能被其他文件所用
+ class中静态数据成员
+ class中静态成员函数 不能访问非静态成员函数和非静态数据成员
  
const
---
`const int func (const int& a) const`

第一个const
+ 函数的返回值类型是const，这个const修饰没什么意义，因为已经是值传递的形式
  
第二个const
+ 修改函数的输入参数，这样可以提高效率
  
第三个函数
+ 表示它不会修改它的数据成员（也就是函数中的变量）。一般来讲，凡是不会修改数据成员的都应该定义为const版本

const和#define比较:
+ 就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用
+ 就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误
+ 就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份
+ 从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了
  
const相对于#define的优点
+ const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误
+ 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试
+ const可节省空间，避免不必要的内存分配，提高效率

const引用和非const引用
+ 非const引用只能绑定到与该引用同类型的对象。const引用可以绑定到不同但相关类型的对象，还可以绑定到右值
```
//legal for const references only
int i = 42;
const int &r = 42;    //对于非const引用不合法
const int &r2 = r + i;

double dval = 3.14;
const int &ref = dval;
```

virtual
---
+ [虚函数](#jump)
+ 虚继承

extern
---
+ extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”
+ extern "C" 如果程序员希望调用其他程序设计语言尤其是C写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写
  
inline
---
在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数
+ inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，
它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已
+ inline函数的定义放在头文件中
+ 虚函数不能inline，一个是运行过程，一个是编译过程
+ 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用
+ 定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好，如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的

inline和宏定义的区别：
+ 内联函数在编译时展开，宏在预编译时展开
+ 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
+ 内联函数是真正的函数，所以要进行一系列的数据类型检查
+ 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
  
volatile
---
 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统，硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问，当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据

friend
---
C++中的友元机制允许类的非公有成员被一个类或者函数访问，友元按类型分为三种：普通非类成员函数作为友元,类的成员函数作为友元，类作为友元

+ 友元不具有相互性，只具有单项性
+ 友元不能被继承 B是A的友元类，C是B的子类，推不出C是A的友元
+ 友元不具有传递性

友元函数：
+ 友元函数的实现可以在类外定义，但必须在类内部声明
+ 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend

类作为友元：
+ 类作为友元需要注意的是友元类和原始类之间的相互依赖关系，如果在友元类中定义的函数使用到了原始类的私有变量，那么就需要在友元类定义的文件中包含原始类定义的头文件。但是在原始类的定义中（包含友元类声明的那个类），就不需要包含友元类的头文件
+ 不需要在类定义前去声明友元类，因为友元类的声明自身就是一种声明

类成员函数作为友元函数：
+ 通常的做法先定义包含友元函数的类，再定义原始类

mutable
---
mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

constexpr
---
constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”

# 四种转换类型
static_cast
---
类似于 C 语言中的类型转换，可以进行无条件类型转换，比如
+ 父类和子类指针之间的转换。如果父类指针指向一个对象，此时将父类指针转换为子类指针是不安全的，子类指针转换为父类指针是安全的
+ 将任何类型的表达式转换为 void 类型

dynamic_cast
---
只能用于对象指针之间的转换。在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的；在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全

const_cast
---
用于取出 const 属性，去掉类型的 const 或者 volatile 属性，将 const 类型的指针变为非 const 类型的指针

reinterpret_cast
---
用来处理无关类型之间的转换，它会产生一个新的值，这个值会有与原始参数（expression）有完全相同的比特位

# c++11
## 智能指针
## 右值
可以对表达式取地址&的为左值，否则为右值，当一个对象被用作右值的时候，用的是对象的值(内容)，当对象被用作左值的时候，用的是对象的身份(在内存中的位置)
### 右值引用
在某些情况下，对象拷贝后就立即被销毁。这些情况下，移动而非拷贝对象会大幅度提升性能。因此，在C++11中引入了右值引用。右值引用必须绑定到右值的引用。通过&&而不是&来获得右值引用。右值引用的一个重要特性——只能绑定到一个将要销毁的对象。因此，可以自由地将一个右值引用的资源”移动”到另一个对象中。类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。对于常规引用(为了与右值引用区分开来，可以称之为左值引用(lvalue reference))，不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上
```
int  i = 42;
int  &r = i;					// 正确：r引用i
int  &&rr = i;					// 错误：不能将右值引用绑定到左值上
int  &r2 = i * 42;				// 错误：i * 42为右值
const  int  &r3 = i * 42;		        // 正确：可以将一个const的引用绑定到右值上
int  &&r2 = i * 42;				// 正确：右值引用可以绑定到右值上
```
观察左右值表达式可知：左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时变量。

由于右值引用只能绑定到临时对象，可知所引用的对象是将要销毁的，该对象没有其他用户。这意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。

+ 变量是左值，不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值也不行
```
int  &&rr1 = 42;		// 正确：字面常量是右值
int  &&rr2 = rr1;		// 错误：表达式rr1是左值
```

### std::move
虽然不能将一个右值引用直接绑定到左值上，但是可以显式的将一个左值转换为对应的右值引用类型。可以使用move库函数来获得绑定到左值上的右值引用，该函数在utility中

从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);
```
int  &&rr1 = 42;
int  &&rr3 = std::move(rr1);
```
### std::forward
完美转发，适用于这样的场景：需要将一组参数原封不动的传递给另一个函数

“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：左值／右值和 const/non-const。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样，在泛型函数中，这样的需求非常普遍

举例说明：
```
#include <iostream>
using namespace std;

template <typename T> void process_value(T & val)
{
    cout << "T &" << endl;
}

template <typename T> void process_value(const T & val)
{
    cout << "const T &" << endl;
}

//函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value
template <typename T> void forward_value(const T& val)
{
    process_value(val);
}

template <typename T> void forward_value(T& val)
{
    process_value(val);
}

int main()
{
    int a = 0;
    const int &b = 1;

    //函数 forward_value 为每一个参数必须重载两种类型，T& 和 const T&
    forward_value(a); // T&
    forward_value(b); // const T &
    forward_value(2); // const T&

    return 0;
}
```
对于一个参数就要重载两次，也就是函数重载的次数和参数的个数是一个正比的关系。这个函数的定义次数对于程序员来说，是非常低效的

C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发
```
typedef const int T;
typedef T & TR;
TR &v = 1; //在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式
```
C++11中的引用折叠规则：
|TR的类型定义|声明v的类型|v的实际类型|
|---|---|---|
|T &|TR|T &|
|T &|TR &|T &|
|T &|TR &&|T &|
|T &&|TR|T &&|
|T &&|TR &|T &|
|T &&|TR &&|T &&|
一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用

C++11中，std::forward可以保存参数的左值或右值特性：
```
#include <iostream>
using namespace std;

template <typename T> void process_value(T & val)
{
    cout << "T &" << endl;
}

template <typename T> void process_value(T && val)
{
    cout << "T &&" << endl;
}

template <typename T> void process_value(const T & val)
{
    cout << "const T &" << endl;
}

template <typename T> void process_value(const T && val)
{
    cout << "const T &&" << endl;
}

//函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value
template <typename T> void forward_value(T && val) //参数为右值引用
{
    process_value( std::forward<T>(val) );//C++11中，std::forward可以保存参数的左值或右值特性
}

int main()
{
    int a = 0;
    const int &b = 1;

    forward_value(a); // T &
    forward_value(b); // const T &
    forward_value(2); // T &&
    forward_value( std::move(b) ); // const T &&

    return 0;
}
```
### lambda表达式
C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作
```
[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}
```
`[函数对象参数]`
标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造
函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量(包括 Lambda 所在类
的 this)。函数对象参数有以下形式：
+ 空。没有任何函数对象参数
+ =。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相
当于编译器自动为我们按值传递了所有局部变量）
+ &。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式
（相当于是编译器自动为我们按引用传递了所有局部变量）
+ this。函数体内可以使用 Lambda 所在类中的成员变量
+ a。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要
修改传递进来的拷贝，可以添加 mutable 修饰符
+ &a。将 a 按引用进行传递
+ a，&b。将 a 按值传递，b 按引用进行传递
+ =，&a，&b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递
+ &，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递

`(操作符重载函数参数)`
标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&a, &b)) 两种
方式进行传递

`mutable 或 exception 声明`
这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是
值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)

`-> 返回值类型`
标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）
时，这部分可以省略

`{函数体}`
标识函数的实现，这部分不能省略，但函数体可以为空
# STL
 vector扩容原理
---
+ vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素
+ 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了
+ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1
+ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容
+ vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好
+ 在C++标准库容器vector的容量是不会自动的缩减的

什么时候迭代器会失效
---
vector
+ 当插入（push_back）一个元素后，end操作返回的迭代器肯定失效
+ 当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效
+ 当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效

list
+ 插入操作（insert）和接合操作（splice）不会造成原有的list迭代器失效，这在vector中是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致所有的迭代器全部失效
+ list的删除操作（erase）也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。（list目前只发现这一种失效的情况）

deque
+ 在deque容器首部或者尾部插入元素不会使得任何迭代器失效
+ 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效
+ 在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效

set和map
+ 与list相同，当对它进行insert和erase操作时，操作之前的所有迭代器，在操作完成之后都依然有效，但被删除的元素的迭代器失效

# 类
## sizeof(类)
+ 为类的非静态成员数据的类型大小之和
+ 有编译器额外加入的成员变量的大小，用来支持语言的某些特性（如：指向虚函数的指针）
+ 为了优化存取效率，进行的边缘调整
+ 与类中的构造函数，析构函数以及其他的成员函数无关
## 类和结构体的区别
+ 结构体内部成员变量及成员函数默认的访问级别是public,而类的内部成员变量及成员函数的默认访问级别是private
+ 结构体的继承默认是public，而类的继承默认是private
+ 结构体成员不能被声明为protected
## 类模板和模板类
+ 类模板是模板的一种， 可以在使用时确定类的类型，类模板不是一个类，不能直接用于生成对象
+ 模板类就是类模板的一个实例，是一个确定了类型的具体的类，可以直接生成对象
## 类中数据成员的初始化
普通成员变量：
+ 普通成员变量是每个对象私有的，一般在类的构造函数中进行赋值（这里不是初始化，普通成员变量一般是在定义后被初始化位一个随机的值，在构造函数里只是进行赋值）

静态成员变量：
+ static成员变量需要在类定义体外进行初始化与定义，因为static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联，一般我会写在cpp文件，构造函数的前面

静态常成员变量：
+ 该类型成员可以直接在类中初始化，也可以在类中声明，在类定义体外进行定义。我一般在.h文件定义的时候直接初始化

常成员变量跟引用成员变量：
+ c++规定const成员和引用成员必须在初始化列表中初始化，而不能在构造函数体内初始化。因为在进入构造函数体内时，实际上变量都已经初始化完毕了，构造函数内能做的只有赋值，而const类型和引用类型是不可以赋值的。所以，需要在初始化列表中初始化

## 基类与派生类之间同名函数重载问题
```
class Base {
 public:
  void print() {
    cout << "print() in Base." << endl;
  }
  void print(int a) {
    cout << "print(int a) in Base." << endl;
  }
  void print(string s) {
    cout << "print(string s) in Base." << endl;
  }
}; 
 
class Derived : public Base { };  
int main() {
  Derived d;
  d.print();
  d.print(10);
  d.print("");
  return 0;
}
```
运行结果十分简单，此处不作分析。

现在，我们想要在派生类中重写其中的一个重载函数:
```
class Derived : public Base {
 public:
  void print() {
    cout << "Rewrite print() in Derived." << endl;
  }
};
```
编译报错：
```
reload_test.cc: In function ‘int main()’:
reload_test.cc:39: error: no matching function for call to ‘Derived::print(int)’
reload_test.cc:21: note: candidates are: void Derived::print()
reload_test.cc:40: error: no matching function for call to ‘Derived::print(const char [1])’
reload_test.cc:21: note: candidates are: void Derived::print()
```
结果匹配不到后两种情况

理解 C++ 中继承层次的关键在于理解如何确定函数调用。确定函数调用遵循以下四个步骤:
1. 首先确定进行函数调用的对象、引用或指针的静态类型
2. 在该类中查找函数,如果找不到,就在直接基类中查找,如此循着类的继承链往上找,直到找到该函数或者查找完最后一个类。如果不能在类或其相关基类中找到该名字,则调用是错误的
3. 一旦找到了该名字,就进行常规类型检查,查看如果给定找到的定义,该函数调用是否合法
4. 假定函数调用合法,编译器就生成代码。如果函数是虚函数且通过引用或指针调用,则编译器生成代码以确定根据对象的动态类型运行哪个函数版本,否则,编译器生成代码直接调用函数
  
当我们在派生类中没有重写重载函数之一的时候，在派生类中调用的重载函数是在其基类中查到的，因此，调用可以成功；然而，当我们仅重写了其中的一个重载函数时，在做函数名匹配时，在本类中就可以匹配到了，就不会向其父类查找了。而在派生类中，仅记录了这个被重写的函数的信息，当然也就没有另外两个重载函数的一些了，因此就导致了上述错误的出现了。换句话说，派生类的函数会将基类中的同名函数屏蔽掉

解决方法：
1. 在派生类中通过using为父类函数成员提供声明
```
class Derived : public Base {
 public:
  using Base::print;
  void print() {
    cout << "print() in Derived." << endl;
  }
```
2. 通过基类指针的调用，在调用被屏蔽的重载函数时，可以不直接通过派生类对象调用，而是通过基类指针指向派生类对象，通过基类指针进行调用，这样就会直接在基类中进行查找函数名，从而可以匹配并进行类型匹配

3. 在基类中用virtual声明子类将要重载的方法版本,然后在子类统一使用基类指针来调用

# 其他(未归类)
## 动态链接 静态链接

## 数组指针和指针数组的区别
```
using namespace std;
int main(){
    
    //a) 一个整型数（ An integer）
    int a;
    //b) 一个指向整型数的指针（ A pointer to an integer）
    int *b;
    //c) 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an integer）
    int **c;
    //d) 一个有 10 个整型数的数组（ An array of 10 integers）
    int d[10];
    //e) 一个有 10 个指针的数组，该指针是指向一个整型数的（ An array of 10 pointers to integers）
    int *e[10]
    //f) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers）
    int (*f)[10];
    //g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（ A pointer to a functionthat takes an integer as an argument and returns an integer）
    int *g(int);
    //h) 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer 
    int (*h[10])(int);
    return 0;
}
```
1. `[]`优先级高于`*`
2. 根据优先级判定是一个数组还是一个指针

## 深拷贝和浅拷贝的区别
浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针

当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形：
1. 当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现
2. 当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处
3. 浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题

## 关于指针和引用的一些思考
```
int i=1;
int *a,b,&c=i;//a为指针,b为整型,c为引用,之前以为这样声明会报错，其实是正确的
a=&c;
cout<<*a<<endl;//输出1
i=2;
cout<<*a<<endl;//输出2
```
这样没有什么问题，来看下一段代码
```
int i=1;
int *a,b,&c=i;
*a=c;
cout<<*a<<endl;//输出1
i=2;
cout<<*a<<endl;//输出1
```
这里为什么输出还是1，而不是随着i也变为2了呢，是因为这里是将c的值拷贝给了*a，而不是把c的地址(也就是i的地址)绑定到了a上
