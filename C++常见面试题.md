# 目录
<!-- GFM-TOC -->
- [目录](#目录)
- [多态](#多态)
  - [静态多态](#静态多态)
    - [函数重载](#函数重载)
      - [为什么C语言不能实现函数重载](#为什么c语言不能实现函数重载)
    - [模板](#模板)
    - [宏定义](#宏定义)
  - [动态多态](#动态多态)
    - [虚函数](#虚函数)
- [关键字](#关键字)
  - [static](#static)
  - [const](#const)
  - [virtual](#virtual)
  - [extern](#extern)
  - [inline](#inline)
  - [volatile](#volatile)
  - [friend](#friend)
  - [mutable](#mutable)
  - [constexpr](#constexpr)
- [四种转换类型](#四种转换类型)
  - [static_cast](#static_cast)
  - [dynamic_cast](#dynamic_cast)
  - [const_cast](#const_cast)
  - [reinterpret_cast](#reinterpret_cast)
- [c++11](#c11)
  - [智能指针](#智能指针)
  - [右值](#右值)
    - [std::move](#stdmove)
    - [std::forward](#stdforward)
- [stl](#stl)
  - [vector扩容原理](#vector扩容原理)
- [其他(未归类)](#其他未归类)
<!-- GFM-TOC -->

# 多态

## 静态多态
编译时的多态

### 函数重载

基于不同的参数列表，同一个函数名字可以指向不同的函数定义，实现原理在于编译器根据不同的参数列表对同名函数进行名字重整，而后这些同名函数就变成了彼此不同的函数

#### 为什么C语言不能实现函数重载
编译器在编译.c文件时，只会给函数进行简单的重命名；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错

### 模板

### 宏定义

## 动态多态
运行时的多态

### 虚函数

# 关键字
static
---

## const
## virtual
extern
---
+ extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”
+ extern "C" 如果程序员希望调用其他程序设计语言尤其是C写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写
  
inline
---
在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数
+ inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，
它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已
+ inline函数的定义放在头文件中
+ 虚函数不能inline，一个是运行过程，一个是编译过程
+ 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用
+ 定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好，如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的

inline和宏定义的区别：
+ 内联函数在编译时展开，宏在预编译时展开
+ 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
+ 内联函数是真正的函数，所以要进行一系列的数据类型检查
+ 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
## volatile
## friend
## mutable
## constexpr

# 四种转换类型
static_cast
---
类似于 C 语言中的类型转换，可以进行无条件类型转换，比如
+ 父类和子类指针之间的转换。如果父类指针指向一个对象，此时将父类指针转换为子类指针是不安全的，子类指针转换为父类指针是安全的
+ 将任何类型的表达式转换为 void 类型

dynamic_cast
---
只能用于对象指针之间的转换。在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的；在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全

const_cast
---
用于取出 const 属性，去掉类型的 const 或者 volatile 属性，将 const 类型的指针变为非 const 类型的指针

reinterpret_cast
---
用来处理无关类型之间的转换，它会产生一个新的值，这个值会有与原始参数（expression）有完全相同的比特位

# c++11
## 智能指针
## 右值
### std::move
### std::forward


# stl
 vector扩容原理
---
+ vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素
+ 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了
+ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1
+ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容
+ vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好
# 其他(未归类)
