# 目录
<!-- GFM-TOC -->
- [目录](#目录)
- [多态](#多态)
  - [静态多态](#静态多态)
    - [函数重载](#函数重载)
      - [为什么C语言不能实现函数重载](#为什么c语言不能实现函数重载)
    - [模板](#模板)
    - [宏定义](#宏定义)
  - [动态多态](#动态多态)
    - [<span id="jump">虚函数</span>](#虚函数)
- [关键字](#关键字)
  - [static](#static)
  - [const](#const)
  - [virtual](#virtual)
  - [extern](#extern)
  - [inline](#inline)
  - [volatile](#volatile)
  - [friend](#friend)
  - [mutable](#mutable)
  - [constexpr](#constexpr)
- [四种转换类型](#四种转换类型)
  - [static_cast](#static_cast)
  - [dynamic_cast](#dynamic_cast)
  - [const_cast](#const_cast)
  - [reinterpret_cast](#reinterpret_cast)
- [c++11](#c11)
  - [智能指针](#智能指针)
  - [右值](#右值)
    - [右值引用](#右值引用)
    - [std::move](#stdmove)
    - [std::forward](#stdforward)
- [stl](#stl)
  - [vector扩容原理](#vector扩容原理)
- [其他(未归类)](#其他未归类)
<!-- GFM-TOC -->

# 多态

## 静态多态
编译时的多态

### 函数重载

基于不同的参数列表，同一个函数名字可以指向不同的函数定义，实现原理在于编译器根据不同的参数列表对同名函数进行名字重整，而后这些同名函数就变成了彼此不同的函数

#### 为什么C语言不能实现函数重载
编译器在编译.c文件时，只会给函数进行简单的重命名；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错

### 模板

### 宏定义

## 动态多态
运行时的多态

### <span id="jump">虚函数</span>


# 关键字
static
---
+ 静态局部变量
+ 静态全局变量 只在本文件可见
+ 静态函数 不能被其他文件所用
+ class中静态数据成员
+ class中静态成员函数 不能访问非静态成员函数和非静态数据成员
  
const
---
`const int func (const int& a) const`

第一个const
+ 函数的返回值类型是const，这个const修饰没什么意义，因为已经是值传递的形式
  
第二个const
+ 修改函数的输入参数，这样可以提高效率
  
第三个函数
+ 表示它不会修改它的数据成员（也就是函数中的变量）。一般来讲，凡是不会修改数据成员的都应该定义为const版本

const和#define比较:
+ 就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用
+ 就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误
+ 就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份
+ 从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了
  
const相对于#define的优点
+ const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误
+ 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试
+ const可节省空间，避免不必要的内存分配，提高效率

virtual
---
+ [虚函数](#jump)
+ 虚继承

extern
---
+ extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”
+ extern "C" 如果程序员希望调用其他程序设计语言尤其是C写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写
  
inline
---
在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数
+ inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，
它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已
+ inline函数的定义放在头文件中
+ 虚函数不能inline，一个是运行过程，一个是编译过程
+ 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用
+ 定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好，如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的

inline和宏定义的区别：
+ 内联函数在编译时展开，宏在预编译时展开
+ 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
+ 内联函数是真正的函数，所以要进行一系列的数据类型检查
+ 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
  
volatile
---
 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统，硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问，当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据

friend
---
C++中的友元机制允许类的非公有成员被一个类或者函数访问，友元按类型分为三种：普通非类成员函数作为友元,类的成员函数作为友元，类作为友元

+ 友元不具有相互性，只具有单项性
+ 友元不能被继承 B是A的友元类，C是B的子类，推不出C是A的友元
+ 友元不具有传递性

友元函数：
+ 友元函数的实现可以在类外定义，但必须在类内部声明
+ 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend

类作为友元：
+ 类作为友元需要注意的是友元类和原始类之间的相互依赖关系，如果在友元类中定义的函数使用到了原始类的私有变量，那么就需要在友元类定义的文件中包含原始类定义的头文件。但是在原始类的定义中（包含友元类声明的那个类），就不需要包含友元类的头文件
+ 不需要在类定义前去声明友元类，因为友元类的声明自身就是一种声明

类成员函数作为友元函数：
+ 通常的做法先定义包含友元函数的类，再定义原始类

mutable
---
mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

constexpr
---
constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”

# 四种转换类型
static_cast
---
类似于 C 语言中的类型转换，可以进行无条件类型转换，比如
+ 父类和子类指针之间的转换。如果父类指针指向一个对象，此时将父类指针转换为子类指针是不安全的，子类指针转换为父类指针是安全的
+ 将任何类型的表达式转换为 void 类型

dynamic_cast
---
只能用于对象指针之间的转换。在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的；在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全

const_cast
---
用于取出 const 属性，去掉类型的 const 或者 volatile 属性，将 const 类型的指针变为非 const 类型的指针

reinterpret_cast
---
用来处理无关类型之间的转换，它会产生一个新的值，这个值会有与原始参数（expression）有完全相同的比特位

# c++11
## 智能指针
## 右值
可以对表达式取地址&的为左值，否则为右值，当一个对象被用作右值的时候，用的是对象的值(内容)，当对象被用作左值的时候，用的是对象的身份(在内存中的位置)
### 右值引用
在某些情况下，对象拷贝后就立即被销毁。这些情况下，移动而非拷贝对象会大幅度提升性能。因此，在C++11中引入了右值引用。右值引用必须绑定到右值的引用。通过&&而不是&来获得右值引用。右值引用的一个重要特性——只能绑定到一个将要销毁的对象。因此，可以自由地将一个右值引用的资源”移动”到另一个对象中。类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。对于常规引用(为了与右值引用区分开来，可以称之为左值引用(lvalue reference))，不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上
```
int  i = 42;
int  &r = i;					// 正确：r引用i
int  &&rr = i;					// 错误：不能将右值引用绑定到左值上
int  &r2 = i * 42;				// 错误：i * 42为右值
const  int  &r3 = i * 42;		        // 正确：可以将一个const的引用绑定到右值上
int  &&r2 = i * 42;				// 正确：右值引用可以绑定到右值上
```
观察左右值表达式可知：左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时变量。

由于右值引用只能绑定到临时对象，可知所引用的对象是将要销毁的，该对象没有其他用户。这意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。

+ 变量是左值，不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值也不行
```
int  &&rr1 = 42;		// 正确：字面常量是右值
int  &&rr2 = rr1;		// 错误：表达式rr1是左值
```

### std::move
虽然不能将一个右值引用直接绑定到左值上，但是可以显式的将一个左值转换为对应的右值引用类型。可以使用move库函数来获得绑定到左值上的右值引用，该函数在utility中

从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);
```
int  &&rr1 = 42;
int  &&rr3 = std::move(rr1);
```
### std::forward
完美转发，适用于这样的场景：需要将一组参数原封不动的传递给另一个函数

“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：左值／右值和 const/non-const。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样，在泛型函数中，这样的需求非常普遍

举例说明：
```
#include <iostream>
using namespace std;

template <typename T> void process_value(T & val)
{
    cout << "T &" << endl;
}

template <typename T> void process_value(const T & val)
{
    cout << "const T &" << endl;
}

//函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value
template <typename T> void forward_value(const T& val)
{
    process_value(val);
}

template <typename T> void forward_value(T& val)
{
    process_value(val);
}

int main()
{
    int a = 0;
    const int &b = 1;

    //函数 forward_value 为每一个参数必须重载两种类型，T& 和 const T&
    forward_value(a); // T&
    forward_value(b); // const T &
    forward_value(2); // const T&

    return 0;
}
```
对于一个参数就要重载两次，也就是函数重载的次数和参数的个数是一个正比的关系。这个函数的定义次数对于程序员来说，是非常低效的

C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发
```
typedef const int T;
typedef T & TR;
TR &v = 1; //在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式
```
C++11中的引用折叠规则：
|TR的类型定义|声明v的类型|v的实际类型|
|---|---|---|
|T &|TR|T &|
|T &|TR &|T &|
|T &|TR &&|T &|
|T &&|TR|T &&|
|T &&|TR &|T &|
|T &&|TR &&|T &&|
一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用

C++11中，std::forward可以保存参数的左值或右值特性：
```
#include <iostream>
using namespace std;

template <typename T> void process_value(T & val)
{
    cout << "T &" << endl;
}

template <typename T> void process_value(T && val)
{
    cout << "T &&" << endl;
}

template <typename T> void process_value(const T & val)
{
    cout << "const T &" << endl;
}

template <typename T> void process_value(const T && val)
{
    cout << "const T &&" << endl;
}

//函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value
template <typename T> void forward_value(T && val) //参数为右值引用
{
    process_value( std::forward<T>(val) );//C++11中，std::forward可以保存参数的左值或右值特性
}

int main()
{
    int a = 0;
    const int &b = 1;

    forward_value(a); // T &
    forward_value(b); // const T &
    forward_value(2); // T &&
    forward_value( std::move(b) ); // const T &&

    return 0;
}
```
# stl
 vector扩容原理
---
+ vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素
+ 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了
+ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1
+ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容
+ vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好
# 其他(未归类)
