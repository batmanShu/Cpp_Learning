# 目录
<!-- GFM-TOC -->
- [目录](#目录)
- [多态](#多态)
  - [静态多态](#静态多态)
    - [函数重载](#函数重载)
      - [为什么C语言不能实现函数重载](#为什么c语言不能实现函数重载)
    - [模板](#模板)
    - [宏定义](#宏定义)
  - [动态多态](#动态多态)
    - [<span id="jump">虚函数</span>](#虚函数)
- [关键字](#关键字)
  - [static](#static)
  - [const](#const)
  - [virtual](#virtual)
  - [extern](#extern)
  - [inline](#inline)
  - [volatile](#volatile)
  - [friend](#friend)
  - [mutable](#mutable)
  - [constexpr](#constexpr)
- [四种转换类型](#四种转换类型)
  - [static_cast](#static_cast)
  - [dynamic_cast](#dynamic_cast)
  - [const_cast](#const_cast)
  - [reinterpret_cast](#reinterpret_cast)
- [c++11](#c11)
  - [智能指针](#智能指针)
  - [右值](#右值)
    - [std::move](#stdmove)
    - [std::forward](#stdforward)
- [stl](#stl)
  - [vector扩容原理](#vector扩容原理)
- [其他(未归类)](#其他未归类)
<!-- GFM-TOC -->

# 多态

## 静态多态
编译时的多态

### 函数重载

基于不同的参数列表，同一个函数名字可以指向不同的函数定义，实现原理在于编译器根据不同的参数列表对同名函数进行名字重整，而后这些同名函数就变成了彼此不同的函数

#### 为什么C语言不能实现函数重载
编译器在编译.c文件时，只会给函数进行简单的重命名；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错

### 模板

### 宏定义

## 动态多态
运行时的多态

### <span id="jump">虚函数</span>


# 关键字
static
---
+ 静态局部变量
+ 静态全局变量 只在本文件可见
+ 静态函数 不能被其他文件所用
+ class中静态数据成员
+ class中静态成员函数 不能访问非静态成员函数和非静态数据成员
  
const
---
`const int func (const int& a) const`

第一个const
+ 函数的返回值类型是const，这个const修饰没什么意义，因为已经是值传递的形式
  
第二个const
+ 修改函数的输入参数，这样可以提高效率
  
第三个函数
+ 表示它不会修改它的数据成员（也就是函数中的变量）。一般来讲，凡是不会修改数据成员的都应该定义为const版本
  
virtual
---
+ [虚函数](#jump)
+ 虚继承

extern
---
+ extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”
+ extern "C" 如果程序员希望调用其他程序设计语言尤其是C写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写
  
inline
---
在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数
+ inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，
它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已
+ inline函数的定义放在头文件中
+ 虚函数不能inline，一个是运行过程，一个是编译过程
+ 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用
+ 定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好，如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的

inline和宏定义的区别：
+ 内联函数在编译时展开，宏在预编译时展开
+ 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
+ 内联函数是真正的函数，所以要进行一系列的数据类型检查
+ 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
  
volatile
---
 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统，硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问，当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据

friend
---
C++中的友元机制允许类的非公有成员被一个类或者函数访问，友元按类型分为三种：普通非类成员函数作为友元,类的成员函数作为友元，类作为友元

+ 友元不具有相互性，只具有单项性
+ 友元不能被继承 B是A的友元类，C是B的子类，推不出C是A的友元
+ 友元不具有传递性

友元函数：
+ 友元函数的实现可以在类外定义，但必须在类内部声明
+ 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend

类作为友元：
+ 类作为友元需要注意的是友元类和原始类之间的相互依赖关系，如果在友元类中定义的函数使用到了原始类的私有变量，那么就需要在友元类定义的文件中包含原始类定义的头文件。但是在原始类的定义中（包含友元类声明的那个类），就不需要包含友元类的头文件
+ 不需要在类定义前去声明友元类，因为友元类的声明自身就是一种声明

类成员函数作为友元函数：
+ 通常的做法先定义包含友元函数的类，再定义原始类

mutable
---
mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中

constexpr
---
constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”

# 四种转换类型
static_cast
---
类似于 C 语言中的类型转换，可以进行无条件类型转换，比如
+ 父类和子类指针之间的转换。如果父类指针指向一个对象，此时将父类指针转换为子类指针是不安全的，子类指针转换为父类指针是安全的
+ 将任何类型的表达式转换为 void 类型

dynamic_cast
---
只能用于对象指针之间的转换。在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的；在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全

const_cast
---
用于取出 const 属性，去掉类型的 const 或者 volatile 属性，将 const 类型的指针变为非 const 类型的指针

reinterpret_cast
---
用来处理无关类型之间的转换，它会产生一个新的值，这个值会有与原始参数（expression）有完全相同的比特位

# c++11
## 智能指针
## 右值
### std::move
### std::forward


# stl
 vector扩容原理
---
+ vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素
+ 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了
+ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1
+ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容
+ vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好
# 其他(未归类)
